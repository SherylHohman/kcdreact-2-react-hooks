# useEffect: persistent state

## 📝 Your Notes

Elaborate on your learnings here in `src/exercise/02.md`

Hooks let you use state and other React features without writing a class.

### Exercise 02.js: useEffect & localStorage

#### useEffect

`useEffect` is similar to **`componentDidMount`** and **`componentDidUpdate`**
and **`componentWillUnmount`** _combined_

The `Effect` Hook lets you perform _side effects_ in function components. It
makes changes _AFTER_ component has _rendered_. Like `componentDidMount` and
`componentDidUpdate`. The effect applies to the _current_ render, and the
function passed in will re-run at the next render.

Examples of common usage:

- **Data fetching**
- setting up a subscription, and
- manually changing the DOM in React components

[useEffect docs](https://reactjs.org/docs/hooks-effect.html)

---

#### Read data from localStorage

`initialName = window.localStorage.getItem('name') ?? initialName`

Syntax: `var aValue = storage.getItem(keyName);`

Returns: A DOMString containing the value of the key. If the key does not exist,
null is returned.

[Storage.getItem() - MDN docs](https://developer.mozilla.org/en-US/docs/Web/API/Storage/getItem)

#### Set data to localStorage

`window.localStorage.setItem('name', name)`

Syntax: `storage.setItem(keyName, keyValue);`

[Storage.setItem() - MDN docs]()
[MDN docs](https://developer.mozilla.org/en-US/docs/Web/API/Storage/setItem)

#### remove data from localStorage

`Storage.removeItem()` When passed a key name, will remove that key from the
storage.

`Storage.clear()` When invoked, will empty all keys out of the storage.

[Storage object - MDN docs]()
[MDN docs](https://developer.mozilla.org/en-US/docs/Web/API/Storage)

#### Javascript refresher

##### ?? - nullish coalescing operator (reminder)

> ?? is like || but for null or undefiend only, rather than falsey (eg 0, ''.)
> It shortcircuits for everything except null or udefined

##### ?. - optional chaining operator

> The ?. operator is like the . chaining operator, except that instead of
> causing an _error_ if a reference is _nullish_ (`null` or `undefined`), the
> expression short-circuits with a return value of `undefined`.\
> When used with function calls, it returns undefined if the given function does
> not exist.

```
let customer = {name: "Carl"};
const customerCity = customer?.city ?? "Unknown city";
// Unknown city
```

Function, Array, & Expression ?. examples:

```
obj.func?.(args)
obj.arr?.[index]
obj.val?.[expr]
obj.val?.prop

let arrayItem = arr?.[42];
  // `undefined`, OR `arr[42]`'s value
let nestedProp = obj?.['prop' + 'Name'];
  // `undefined` OR value of `arr[propName]`

function doSomething(onContent, onError) {
  try { // ... do something with the data }
  catch (err) {
    onError?.(err.message);
    // no exception if onError is undefined
  }
}
```

---

### Exercise 02.extra-1.js:

#### useState

useState and setState are Asynchronous useState is called again at EVERY
re-render. So, it is RECREATING the var and setVar every time. BUT at subsequent
calls, instead of setting var to the initial value, it is set to the last value
that was saved via the setVal function. The val is actually "reassigned" (it is
a new copy of a const variable) a value at every render, equal to whatever value
was set last time setVal was called.

I think mentally, I was treating it as a global variable, without realizing that
that is what I was doing. I kind of just kept the same var as before, with its
prev value. setVal is also a new function.

(BTW, window.localStorage.getItem()/setItem() is Synchronous!!, unlike data
fetching from a server via an http request.)

Pass a callback with useState if the function ............

For example, ,,,,,,,,,,,,,,,,,,,,,,,,,,

OK. Very useful:
https://kentcdodds.com/blog/use-state-lazy-initialization-and-function-updates

When call a function with arguments, if any of those arguments are expressions,
including function calls, it first determines the result of those expressions
(including executing function calls invoked.)

Then it calls the (outer/main) function (in question), sending the argument
values, including results from any expressions.

Once the function is invoked, the function decides what to do with those values.

In the case of useState, the value passed in is only used once: the first time
it is rendered -- at the time the component is mounted.

At subsequent renders, the parameter is ignored. It somehow knows it already
exists, and uses the last value stored via its last call to setWhatever (or the
initial value, if setWhatever has never been called to update the state value),
to set _the new_ instance of the Whatever variable to that stored state value.

The thing is, if the initialValue is a number, string etc, there is zero
overhead. If it is a simple function returning the same, the "oerhead" to rerun
the function is, again, incredibly small, can be ignored.

But, if the function is computationally intensive, it will cycle up some CPU,
and take time. Time for something that will just be ignored/thrown away once the
useState function gets it.

So, for computationally intensive functions, we do not want to _invoke_ the
expensive function, sending in the results of that function.

Instead, we want to send in a non-invoked function, and have useState decide
what to do with it. If First Render (just mounted), we want useState to invoke
that function to get, then set, the initial value.

If it is a re-render has no need for the parameter, so it ignores it and throws
it away as always.

So, the way we acomplish this is to send in an anonymous function that returns
the expensiveFunction that is to be used to determine/set the initialValue.

window.localStorage.getItem() is an expensive function. It needs only be called
when the component is mounted (eg on page load / page "refresh").

NO:

```
const initialValue = window.localStorage.getItem('name')
  // this literally has to re-read the Storage on every render. But then useState ignores this (expensive) value, on every re-render. (only used at first mount)
const [name, setName] = useState(initialValue)
```

YES:

```
const initialValue = ()=> window.localStorage.getItem('name')
  // this is a function definition that does not get invoked. (fast, no real overhead.) useState then invokes it when the component is mounted, but discards the anon function without invoking it on re-renders.
const [name, setName] = useState(initialValue)
```

Another way to write this is as:

NO:

```
const [name, setName] = useState(window.localStorage.getItem('name'))
```

YES:

```
const [name, setName] = useState(()=> window.localStorage.getItem('name'))
```

---

###### summary version (useState lazy initialization):

useState takes 2 forms for the paramater passed in (function overloading)

    - send in a value (including from the result of an invoked function).
    - send in a function that it should invoke.

In both cases, the parameter is used only used the first time the component
renders, and ignored for all subsequent re-renders.

When passed a function, the hook invokes it internally. In contrast, if an
_invoked_ function is in the argument list, it is invoked at every render, by
the Component, _before_ the _result_ is passed in to the useState hook. That
means that the function is during all re-renders, even though the _result_ of
that function call is ignored by setState! This causes unnecessary bottlenect,
slowness, if the function is computationally expensive. (eg reading
localStorage)

The practice of passing in a (non-invoked) function (usually in the form of an
anon function: `setState( ()=> {...; return expensiveInitialValue})`) is known
as _lazy initialization_ because the function is invoked only when it is needed,
ie at first render.

---

###### rambling version (useState, setState function overloading):

Ok, so useState has a function overload. (BTW, useMemo does NOT)

(useState's return function _also_ as 2 forms. value and function using
prevValue to generate the new value)

- can pass in a value (an invoked function is the same, as it returns a
  value)<br /> In this case this is assigned as the initial value. Rem: if a
  function invocation is passed, the function is FIRST run to get its return
  value, then the RESUST is passed in as an initial value. If the function is
  expensive, we do NOT want to run the function first, since the supplied value
  is ignored on subsequent renders
- Function Overload: or can pass in an (non-invoked) function definition (eg: an
  anon function that returns a function: ()=>{// expensive calculation}). On
  initial render (ie at component mount) useState will internally invoke that
  passed in function, and set its initial state to the value it returned. On
  subsequent renders, of course the value passed in is ignored, so that
  expensive (usu anon) function is ignored, and the expensive calculation has
  been avoided. REM this is because "_function overload_" AND because, we did
  not run the expensive function (to get its result) _before_ calling setState.

the updater function that setState is assigned to _also_ takes 2 forms
` [myValue, setMyValue] = setState(initialValue) // or setState(()=>{return expensiveInitialValue()})`
Now setMyValue _also_ ahs 2 forms:

- `setMyValue(newValue)
- `setMyValue( prevValue => {<do stuff with prevValue>; return newValue}` Note,
  also that setMyValue does _NOT merge_ with previous state value. It _replaces_
  the previous value. This is a departure from this.`setState()` of class-based
  components. But that makes sense. with this.setStage, there was only 1 "state"
  object. Here, we generally have a separate state object for each value we want
  to keep. It is as though we "unwrapped" the setState's object and just access
  those (formerly keys, when they were part of a state object) as variables
  directly. )

###### TLDR; version

useState can take a value OR a callback argument.

Use a callback if determining the initial value requires an expensive process,
but it Synchronous. Like reading from the browser Storage. (for Asynch, need to
use useEffect or something else.)

Otherwise, just pass in the value, or a function expression (invoked function).

Just remember that the function expression will be run at EVERY re-render,
before it can pass the return value into useState. But useState only uses the
argument for the first render.

So if the function expression is expensive, it is run for nothing, since its
result will always be ignored, except when the component is mounted.

---

## Background

`React.useEffect` is a built-in hook that allows you to run some custom code
after React renders (and re-renders) your component to the DOM. It accepts a
callback function which React will call after the DOM has been updated:

```javascript
React.useEffect(() => {
  // your side-effect code here.
  // this is where you can make HTTP requests or interact with browser APIs.
})
```

### KCD Aside

Feel free to take a look at `src/examples/hook-flow.png` if you're interested in
the timing of when your functions are run. This will make more sense after
finishing the exercises/extra credit/instruction.

## Exercise

Production deploys:

- [Exercise](https://react-hooks.netlify.app/isolated/exercise/02.js)
- [Final](https://react-hooks.netlify.app/isolated/final/02.js)

In this exercise, we're going to enhance our `<Greeting />` component to get its
initial state value from localStorage (if available) and keep localStorage
updated as the `name` is updated.

## Extra Credit

### 1. 💯 lazy state initialization

[Production deploy](https://react-hooks.netlify.app/isolated/final/02.extra-1.js)

Right now, every time our component function is run, our function reads from
localStorage. This is problematic because it could be a performance bottleneck
(reading from localStorage can be slow). And what's more we only actually need
to know the value from localStorage the first time this component is rendered!
So the additional reads are wasted effort.

To avoid this problem, React's useState hook allows you to pass a function
instead of the actual value, and then it will only call that function to get the
state value when the component is rendered the first time. So you can go from
this: `React.useState(someExpensiveComputation())` To this:
`React.useState(() => someExpensiveComputation())`

And the `someExpensiveComputation` function will only be called when it's
needed!

Make the `React.useState` call use lazy initialization to avoid a performance
bottleneck of reading into localStorage on every render.

> Learn more about
> [lazy state initialization](https://kentcdodds.com/blog/use-state-lazy-initialization-and-function-updates)

### 2. 💯 effect dependencies

[Production deploy](https://react-hooks.netlify.app/isolated/final/02.extra-2.js)

The callback we're passing to `React.useEffect` is called after _every_ render
of our component (including re-renders). This is exactly what we want because we
want to make sure that the `name` is saved into localStorage whenever it
changes, but there are various reasons a component can be re-rendered (for
example, when a parent component in the application tree gets re-rendered).

Really, we _only_ want localStorage to get updated when the `name` state
actually changes. It doesn't need to re-run any other time. Luckily for us,
`React.useEffect` allows you to pass a second argument called the "dependency
array" which signals to React that your effect callback function should be
called when (and only when) those dependencies change. So we can use this to
avoid doing unnecessary work!

Add a dependencies array for `React.useEffect` to avoid the callback being
called too frequently.

### 3. 💯 custom hook

[Production deploy](https://react-hooks.netlify.app/isolated/final/02.extra-3.js)

The best part of hooks is that if you find a bit of logic inside your component
function that you think would be useful elsewhere, you can put that in another
function and call it from the components that need it (just like regular
JavaScript). These functions you create are called "custom hooks".

Create a custom hook called `useLocalStorageState` for reusability of all this
logic.

### 4. 💯 flexible localStorage hook

[Production deploy](https://react-hooks.netlify.app/isolated/final/02.extra-4.js)

Take your custom `useLocalStorageState` hook and make it generic enough to
support any data type (remember, you have to serialize objects to strings... use
`JSON.stringify` and `JSON.parse`). Go wild with this!

## Notes

If you'd like to learn more about when different hooks are called and the order
in which they're called, then open up `src/examples/hook-flow.png` and
`src/examples/hook-flow.js`. Play around with that a bit and hopefully that will
help solidify this for you. Note that understanding this isn't absolutely
necessary for you to understand hooks, but it _will_ help you in some situations
so it's useful to understand.

> PLEASE NOTE: there was a subtle change in the order of cleanup functions
> getting called in React 17:
> https://github.com/kentcdodds/react-hooks/issues/90

## 🦉 Feedback

Fill out
[the feedback form](https://ws.kcd.im/?ws=React%20Hooks%20%F0%9F%8E%A3&e=02%3A%20useEffect%3A%20persistent%20state&em=).
